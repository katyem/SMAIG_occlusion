1, 1, 1,
1, 1, 0), ncol=10,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
for (i in 1:10) {
for (j in 1:3) {
print(round(cubeColor[j,i], 1))
}
}
colnames(cubeColor) <-  c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow')
thisColor <- c(0,0,0) #used to store pixel channel values
tempColor <- c(0,0,0)
tempCC <- 0
tempX <- 0
tempY <- 0
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
tempCount = tempCount +1
tempColor[1] = thisColor[1]
tempColor[2] = thisColor[2]
tempColor[3] = thisColor[3]
tempX = x
tempY = y
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
im_names <- list.files (path = picPath); #folder with pictures in your working directory
cnt = 1
cubesInStack <- 10 # number of cubes per stack/image
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0), ncol=10,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
for (i in 1:10) {
for (j in 1:3) {
print(round(cubeColor[j,i], 1))
}
}
colnames(cubeColor) <-  c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow')
thisColor <- c(0,0,0) #used to store pixel channel values
tempColor <- c(0,0,0)
tempCC <- 0
tempX <- 0
tempY <- 0
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
tempCount = tempCount +1
tempColor[1] = thisColor[1]
tempColor[2] = thisColor[2]
tempColor[3] = thisColor[3]
tempX = x
tempY = y
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
im_names <- list.files (path = picPath); #folder with pictures in your working directory
cnt = 1
cubesInStack <- 10 # number of cubes per stack/image
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0), ncol=10,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
for (i in 1:10) {
for (j in 1:3) {
print(round(cubeColor[j,i], 1))
}
}
colnames(cubeColor) <-  c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow')
thisColor <- c(0,0,0) #used to store pixel channel values
tempColor <- c(0,0,0)
tempCC <- 0
tempX <- 0
tempY <- 0
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
tempCount = tempCount +1
tempColor[1] = thisColor[1]
tempColor[2] = thisColor[2]
tempColor[3] = thisColor[3]
tempX = x
tempY = y
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
## Run code below to save to xls file
colorCount[1,1] <- 0
colorCount <- colorCount[order(colorCount[, 1], decreasing=FALSE),]
## save image names to first row of colorCount matrix
colorCount[1,1] <- "color code"
## Run code below to save to xls file
colorCount[1,1] <- 0
colorCount <- colorCount[order(colorCount[, 1], decreasing=FALSE),]
## save image names to first row of colorCount matrix
colorCount[1,1] <- "color code"
cnt = 1
for (imName in im_names) {
cnt = cnt+1
colorCount[1,cnt] <- imName
}
## Run code below to save to xls file
colorCount[1,1] <- 0
colorCount <- colorCount[order(colorCount[, 1], decreasing=FALSE),]
## save image names to first row of colorCount matrix
colorCount[1,1] <- "color code"
cnt = 1
for (imName in im_names) {
cnt = cnt+1
colorCount[1,cnt] <- imName
}
cnt
thisColor <- c(0,0,0) #used to store pixel channel values
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
##install.packages('imager')
library('imager')
library(xlsx)
getwd()
setwd("D:/R stuff/SMAIG_occlusion/")
picPath <- "smaigColor/"  ## CHANGE to appropriate image sub-folder
im_names <- list.files (path = picPath); #folder with pictures in your working directory
cnt = 1
cubesInStack <- 10 # number of cubes per stack/image
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0), ncol=10,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
for (i in 1:10) {
for (j in 1:3) {
print(round(cubeColor[j,i], 1))
}
}
colnames(cubeColor) <-  c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow')
thisColor <- c(0,0,0) #used to store pixel channel values
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
cNames = c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow')
colnames(colorCount) <-  cNames
colnames(colorCount) <-  cNames
View(colorCount)
## Run code below to save to xls file
write.xlsx(colorCount, "colorCount.xlsx", col.names=FALSE, row.names=FALSE) # each column = image; rows = non-black color categories (.1-1); black == 0, white = 1
## Run code below to save to xls file
write.xlsx(colorCount, "colorCount.xlsx", col.names=T, row.names=T) # each column = image; rows = non-black color categories (.1-1); black == 0, white = 1
##install.packages('imager')
library('imager')
library(xlsx)
getwd()
setwd("D:/R stuff/SMAIG_occlusion/")
picPath <- "smaigColor/"  ## CHANGE to appropriate image sub-folder
im_names <- list.files (path = picPath); #folder with pictures in your working directory
cnt = 1
cubesInStack <- 10 # number of cubes per stack/image
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0), ncol=10,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
cNames = c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow')
colnames(cubeColor) <-  cNames
thisColor <- c(0,0,0) #used to store pixel channel values
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
colnames(colorCount) <-  cNames
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
View(colorCount)
## Run code below to save to xls file
write.xlsx(colorCount, "colorCount.xlsx", col.names=T, row.names=T) # each column = image; rows = non-black color categories (.1-1); black == 0, white = 1
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0,
0, 0, 0), ncol=10,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0,
0, 0, 0), ncol=11,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
cNames = c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow', 'black')
colnames(cubeColor) <-  cNames
thisColor <- c(0,0,0) #used to store pixel channel values
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
colnames(colorCount) <-  cNames
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
View(colorCount)
View(colorCount)
View(colorCount)
View(cubeColor)
View(colorCount)
View(colorCount)
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
colnames(colorCount) <-  cNames
cNames = c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow', 'black')
# Identify 10 different colors and count the occurrence to determine cube occlussion
# rows == colors of each cube
cubeColor  <- matrix(
c(0, 0, 1,
1, 0.3, 0.3,
0.5, 1, 0,
0.5, 0.3, 0.1,
0, 1, 1,
0, 0.4, 0,
0.6, 0, 0.8,
0.7, 0.7, 0.7,
1, 1, 1,
1, 1, 0,
0, 0, 0), ncol=11,nrow=3)  ## The colors used for each of ten cubes (three color channels vs the one used in gray scale)
cNames = c('blue', 'brown1', 'chartreuse1', 'chocolate4', 'cyan', 'darkgreen', 'darkviolet', 'gray', 'white', 'yellow', 'black')
colnames(cubeColor) <-  cNames
cnt = 1
cubesInStack <- 10 # number of cubes per stack/image
View(colorCount)
View(cubeColor)
thisColor <- c(0,0,0) #used to store pixel channel values
imCount <- 0
colorCount <- matrix(0, NROW(im_names),cubesInStack )  # set up matrix: images==rows
colnames(colorCount) <-  cNames
rownames(colorCount) <- im_names
NROW(im_names)
colorCount <- matrix(0, NROW(im_names), NCOL(cubeColor) )  # set up matrix: images==rows
colnames(colorCount) <-  cNames
rownames(colorCount) <- im_names
for (imName in im_names) {
temp <- paste(picPath, imName, sep='');
im <- load.image(temp);  #sets the name of the image in the loop que
imCount <- imCount + 1
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:cubesInStack) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
thisColor[3]
thisColor[2]
thisColor[1]
round(as.numeric(im[x,y,1,3]),1)
cubeColor[2,cc]
thisColor <- c(0,0,0) #used to store pixel channel values
imCount <- 0
colorCount <- matrix(0, NROW(im_names), NCOL(cubeColor) )  # set up matrix: images==rows
colnames(colorCount) <-  cNames
rownames(colorCount) <- im_names
for (imName in im_names) {
##temp <- paste(picPath, imName, sep='')
im <- load.image(paste(picPath, imName, sep=''))  #sets the name of the image in the loop que
imCount <- imCount + 1 # increment the count for the loop (there is most likely a better way to do this)
# I really miss double plus incrementation (word?): imCount++;
tempCount = 0
for (x in 1:width(im)) {  # width
for (y in 1:height(im)) {  # height
thisColor[1] <- round(as.numeric(im[x,y,1,1]),1) # The 1st color  of the pixel at location x,y
thisColor[2] <- round(as.numeric(im[x,y,1,2]),1) # The 2nd color  of the pixel at location x,y
thisColor[3] <- round(as.numeric(im[x,y,1,3]),1) # The 3rd color  of the pixel at location x,y
# roll through cubeColor to see if there is a match for this pixel across three channels
#if (thisColor[1] != 0 && thisColor[2] != 0 && thisColor[3] != 0) { #skip the search, color is black
for (cc in 1:NCOL(cubeColor)) {
#if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
if (thisColor[1] == cubeColor[1,cc] && thisColor[2] == cubeColor[2,cc] && thisColor[3] == cubeColor[3,cc]) {
colorCount[imCount, cc] = colorCount[imCount, cc] + 1
}
}
# }
}
}
print(imName);  print(imCount);
}
## Run code below to save to xls file
write.xlsx(colorCount, "colorCount.xlsx", col.names=T, row.names=T) # each column = image; rows = non-black color categories (.1-1); black == 0, white = 1
